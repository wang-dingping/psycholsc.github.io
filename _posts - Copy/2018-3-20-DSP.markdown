---
layout: post
title:  "DSP 简单学习笔记"
date:   2018-03-20 00:41:13 +0000
categories: git push
comments: true
---

校园网状态较差，公式加载缓慢。

<script type="text/javascript" 
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

# DSP - 数字信号处理

---

数字计算机的出现和高速发展为信号处理提供了强有力的手段，而在目前的许多应用方面，数字方法也逐渐替代了传统的模拟方法进行信号处理。

在这里假定所有人对基础知识有一定的了解。

## 1. 离散傅里叶变换（DFT）

对于序列长度已知的离散时间序列，我们定义了一种离散傅里叶变换（DFT，下同）。此处对DFT的推导过程和若干性质进行简单讨论。

### 常见的几种傅里叶变换形式

傅里叶变换实际上就是以时间为自变量的信号与以频率为自变量的信号的转化关系。以时间为自变量的信号在傅里叶变换的作用下会得到以频率为自变量的信号，同理做反变换会得到相反的结论。

1.非周期连续时间信号

根据《信号与系统》中的相关内容，对非周期的连续信号$$x(t)$$做傅里叶变换得到的结果是

$$X(j\Omega)=\int_{-\infty}^{\infty}x(t)e^{-j\Omega t}dt$$

$$x(t)=\frac{1}{2\pi}\int_{-\infty}^{\infty}X(j\Omega)e^{j\Omega t}d\Omega$$

其变换的图像如下所示（示例）

![pic1](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/DFT-1.png)
![pic2](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/DFT-2.png)

我们可以看出（其实现在还看不出来。。）一个规律，即**非周期信号产生了连续的傅里叶变换**（可以认为是非周期信号不存在最小周期，可以认为最小周期是无穷大，那么最大频率间隔就是无穷小，就像在傅里叶级数向傅里叶变换转化的过程中那样的微妙变化），且**连续的时间信号产生了非周期的频谱**（连续时间信号可以通过分解得到不同大小的频率分量，这个分量没有呈现明显的周期性）。

2.周期连续时间信号

对于周期为T的信号，其傅里叶变换一定是离散的频率函数。

$$X(k\Omega)=\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}x(t)e^{-jk\Omega t}dt$$

$$x(t)=\sum_{k=-\infty}^{\infty}X(k\Omega)e^{jk\Omega t}d\Omega$$

其变换的图像如下（示例）

![pic1](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/DFT-3.png)
![pic2](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/DFT-4.png)

实际上频域值的某种情况就是常见的傅里叶级数。我们经常认为傅里叶级数是这样的形式。

$$a_{k}=\frac{1}{T}X(j\Omega)|_{\Omega = k\omega_{0}}$$

对于存在周期的时间信号，对其做傅里叶分解时一定会得到以某一组以基波频率为主的时间信号。我们不妨只取这个信号的振幅大小作为参考，绘制在一个以频率为自变量的轴上，此时我们便得到了傅里叶变换（级数）。而连续信号得到的频域变换此时仍然没有形成周期的理由。

>傅里叶级数是一种用来分析频域的方式，通过某种变换积分变换，我们能够将周期信号中的某些信息从中摘出。由于三角函数系的正交性，我们很容易得到某个周期信号（函数）是可以分解为若干（甚至无穷多）个正弦信号（函数）。因此我们可以通过傅里叶级数简单分析某种信号的频域组成。而当信号是有限长非周期时，我们往往可以认为信号周期是无穷大（$$\infty$$），而每条频率谱线的间隔就和周期有关，周期越大则谱线会越密集，最终形成一个连续函数。

**拖更上瘾、学业繁忙**

3.非周期离散时间信号

对于非周期信号，我们很容易猜测其傅里叶变换是连续的，同理可以猜测离散时间信号的傅里叶变换是周期的。实际上正是如此。其变换对已经被严格证明，结果如下：

$$X(e^{j\omega})=\sum_{n=-\infty}^{\infty}x(n)e^{-j\omega n}$$

$$x(n)=\frac{1}{2\pi}\int_{-\pi}^{\pi}X(e^{j\omega})e^{j\omega n}d\omega$$

![pic1](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/DFT-5.png)
![pic2](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/DFT-6.png)

相比上面的$$\Omega$$，这里使用了小写的$$\omega$$来代替。因为此时$$\omega$$是**数字域频率**

>角频率 $$\Omega_{s}=\frac{2\pi}{T}$$ 
数字频率$$\omega_s=2\pi$$
物理频率$$f=\frac{1}{T}$$（模拟频率）

4.周期离散时间信号

既然存在以上三种变换，那么我们可以大胆认为存在第四种从离散到离散的傅里叶变换。以第三种为例，如果对第三种变换的频谱进行取样，那么该信号在时域上就会变成周期延拓。此时我们得到的变换就是周期离散到周期离散的对应变换。

![pic1](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/DFT-7.png)
![pic2](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/DFT-8.png)

那么我们就可以得到一个结论：**假如一个函数在一个域内是周期的，那它在另一个域内必然是取样的；如果一个函数在一个域内是取样的，那它在另一个域内必然是周期的。**

---

### 离散傅里叶级数

使用计算机对信号进行频谱分析时往往要求输入和输出都是离散的（否则会对计算造成麻烦）。为了有利于信号的处理，我们最终对信号进行处理的时候都会使用类似上述最后一种变换的方式进行处理。我们往往称这种形式为傅里叶级数（DFS）。

由前面的推导（规律）已经可以知道，离散傅里叶级数是对一个离散时间序列计算傅里叶级数。以第三种变换为例进行推导。

为了更清楚表现周期性问题，我们在后面的表达中会使用$$\widetilde{X}$$这样的方式表示周期性。

设序列x(n)的长度为N，则

$$\widetilde{X}(e^{j\omega})=\sum_{n=0}^{N-1}x(n)e^{-j\omega n}$$

使用数字频率表示谱线间隔时，$$\omega_I = \frac{2\pi}{N}$$

则离散的序列位置可以用$$\omega = k\omega_I$$来表示，其中$$k=0,1,2,...,N-1$$

于是原傅里叶级数就可以写作$$\widetilde{X}(k)=\widetilde{X}(e^{j\omega})\mid_{\omega=\frac{2\pi}{N}k}=\sum_{n=0}^{N-1}\widetilde{x}(n)e^{-j\frac{2\pi}{N}k}$$

容易证明其存在周期性，$$T=N$$

对于逆变换的过程，常常会利用表达式的正交性等性质，此处可以使用求和的方式

$$\sum_{n=0}^{N-1}\widetilde{X}(k)e^{j\frac{2\pi}{N}kr}=\sum_{n=0}^{N-1}(\sum_{n=0}^{N-1}\widetilde{x}(n)e^{-j\frac{2\pi}{N}kn})e^{j\frac{2\pi}{N}kr}$$

很容易推导出逆变换的表达式
$$\widetilde{x}(n)=IDFS[X(k)]=\frac{1}{N}\sum_{n=0}^{N-1}\widetilde{X}(k)e^{j(\frac{2\pi}{N})nk}$$

离散傅里叶级数（DFS）的简单推导如此，对于离散傅里叶变换（DFT）来说过程相似，只是去除了原x和X上的曲线，取消周期性，其他相同，表达式可以写作
$$X(e^{j\omega})=DFT[x(n)]=\sum_{n=0}^{N-1}x(n)e^{-j\omega n}$$

$$x(n)=IDFT[X(k)]=\frac{1}{N}\sum_{n=0}^{N-1}X(k)e^{j(\frac{2\pi}{N})nk}$$

无论计算如何，实际上公式并不重要，理解原理十分重要。对于离散傅里叶级数来说，由于其原时域信号与频域信号都是周期离散的信号，因此处理起来仍有一定难度，因为是无限长信号。但是正因为其周期性，我们仅仅取出其中的一个周期（即**主值序列**），就可以完整地得到整个信号的信息。

所以我们在实际应用中常常使用的是离散傅里叶变换，对离散傅里叶级数的推导只是起到一个中间作用。使用DFT时要注意若干问题

1. DFT只有N个独立的复数值。离散傅里叶级数是周期序列，计算起来仍存在困难，但周期序列中也只有N个独立复值，只知道主值序列后，其整个信号的内容也就都知道了。取消时域与频域信号的周期性，只对单一周期进行操作，我们就容易得到DFT。

2. DFT是隐含周期性的，虽然在变换对上两者都是不含周期性的，但是DFT隐含周期。因为我们实际上是直接取得了DFS的主值序列，要知道实际上还是存在周期问题的。

3. 频域信号每两个谱线之间的距离被称为频率分辨率，很容易知道频率分辨率越高，信号处理的精度就越高。频率分辨率常被定义为$$\frac{f_s}{N}$$，N就是序列的有效数据长度。有关频率分辨率的话题我们后面会继续说到。

4. 使用DFT对信号处理的本质是对连续信号的逼近、近似。由于连续信号在计算机中并不是可操作的，计算时一定会选取其取样值，对离散数据进行计算。这样大大提高了计算的可行性，但是也注定DFT的计算永远是近似计算。近似问题下面也会说到。

先来介绍DSP过程中选用DFT的方法带来的问题。我们提到过DFT的计算是近似计算，具体就体现在这种地方

#### 一、 混叠现象

离散值是通过对连续值得采样得到，采样的频率该如何选择是一个问题。但是这个问题早在一百年前就得到了奈奎斯特(Nyquist)的解决。我们知道对于一个信号，如果做傅里叶变换（这里采用连续信号），会得到一个频域图像。假设这个图像是带限信号。对时域进行采样时，很容易计算出，频域相当于对一个单位冲激串进行卷积，使原本聚集在中间的频域图像平移到每一个冲激所在位置。如果冲激串之间的间隔较小，这时候就会出现较为明显的频率混叠现象，图片说明日后补全。

因此在采样时，采样频率存在一定限制，即$$f_s > 2f_h$$

这里说的$$f_h$$一般被称为高频容量，即这个系统在此时允许处理的信号的最高频率。
但是这个数值并不是越高越好的。简单分析一下。时域上越短的信号，其包含的频率信息就越多，单位冲激函数的傅里叶变换是一个全频域信号。因此假设存在一个较短的时域信号，其高频分量很多，需要系统的$$f_h$$也很高。这时我们在频域上的到的信号频宽很长，如果维持N不变的话，容易看出此时的频率分辨率降低了。此时需要更多的采样点N的数量，否则分析信号时就会出现较大误差。

#### 二、 栅栏效应

栅栏效应时常会出现。在处理一个未知频率的信号时，我们会选择一个可能并不合适的采样频率。这样说的原因就是，一般采样频率会选取基频的整数倍，若非如此，我们可以观测到如下的问题

（图片随缘补

我们看见原本应该出现的一个频率尖峰消失了，代替的是几个较低的峰值。我们通过DFT观测信号时就像隔着栅栏观看一个物体，栅栏很有可能会把原本应该出现的信息挡住，使我们无法正常观测。而这带来的影响未必是信息的丢失，还有可能是信息的错误，就像本图中介绍的那样。

从图像中我们可以看出来，当选择的采样频率合适时，出现的谱线是十分正常的谱线，与计算结果相同；然而当并不是整数倍时，我们看到频谱图线出现了明显的偏差。为了避免这种问题，我们时常会人为补零。经过补零后原信号有效长度未发生改变，但是总长度增加。这样一来就可以让原谱线变得更加细致，可以从中看到栅栏挡住的内容。

#### 三、 频谱泄漏

实际上需要将信号的观察时间限制在一定的时间间隔之内，由于我们无法等待足够长的时间而取用无限多组数据，因此要选择一段信号进行分析。将信号截断的过程相当于信号乘窗函数的过程，这个过程也是我们常说的加窗过程。选择矩形窗的过程一般也被认为是“不加窗”的过程（这里需要意会）。根据傅里叶变换的性质，这个操作相当于频谱信号对这个方波（准确来说是个门函数吧。。）的卷积。这个卷积操作产生的失真一般被称为频率泄漏。

实际应用中我们可以很明显看到加窗以后的高频失真问题，图以后补上。

泄漏的过程与信号的混叠是分不开的，但截断数据也是处理过程中必要的过程。在信号处理的过程中必须要设法抑制这个过程。

把上面说的内容**总结**一下，为了把无限长信号进行处理，往往选择加窗的方式对信号做截断，截断后再做具体处理（截断信号就是时域上让原信号乘门函数，使得信号称为有限长序列）。但是截断信号后会出现问题，往往是原信号中出现高频量，影响了原信号的信噪比。而出现这个变化的原因是截断信号时采用的门函数的长度并不是原信号周期的整数倍。我们知道信号进行傅里叶变换后出现众多频率分量，同时满足所有分量的周期整数倍是不实际的，实际操作中我们往往连信号的具体变换结果都不知晓，因此出现频谱泄漏现象是正常的。
为了抑制高频噪声（当然也可能出现其他噪声信号），必须要做一定处理。这里经常做的处理是

下回再说。



**FFT 基本原理**

1.  FFT引入

FFT是为了减少DFT计算次数而引入的快速有效的算法。对于DFT问题的直接计算，常用公式为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

二者的主要差别在于W上的指数出现不同，以及一个比例因子（实际上分析过程中更经常考虑的是相对值的比例关系）。

由于计算时采用的信号和变换结果都是复序列，直接计算需要N次计算，复数乘积需要N-1次加法运算，对于N个点的变换结果，一共需要![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)次复数乘法和N(N-1)次的复数相加。如果将乘法分解为加法运算，我们容易发现整个DFT过程需要4![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)次乘法运算和2N(N-1)次相加。计算量巨大，因此需要FFT的改进。而改善的基本思路就是利用DFT的一些性质，例如对称性和周期性等，可以将有些项合并或分解。

2.  按时间抽取（DIT）的FFT

此时假设![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)，即2的整数次幂。如果不满足这个条件，就要采用补零的方式人为添加到这个点数。这种FFT也成为基-2FFT。

此时按时间抽取时间序列为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)

则原式可以写成

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)

其中前者n为偶数，后者n为奇数，因此将n替换为对应的r后，容易整理得到

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png)

两项分别为奇序列和偶序列。这样就能够把一个长度为N的序列分解为两个N/2长度的序列进行计算。但是此时算得的内容还只是所需内容的前一半。根据W的对称性，我们可以得到后一半的表达式

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)

将两部分合并得到的就是完整的变换结果。此时使用的时间就会大大减少。又容易知道，由于![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)，因此容易知道N/4也是整数。那么还可以对奇序列和偶序列继续进行和上方相似的分解，由上面分析的原理可以知道，计算速度会进一步加快。可以计算得到，整个操作中进行的复乘法数和复加法数都与![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png)成正比，因此可以记时间复杂度为![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png)，当数量N较大时，计算速度相比DFT提升十分明显。

按时间抽取的FFT算法中，我们发现每一级FFT中的计算都是N个复数经过N/2个蝶形运算后变成了另外N个复数据，而每一级的数据经过计算后都可以直接抹去，对后面的计算没有影响，因此只用N个寄存器就能完成整个计算的过程，所有的计算都在原位完成，节省设备降低成本。

输出往往是乱序的，又或是单纯输入乱序，这个原因是二进制反序问题。

| 序号 | 二进制码 | 反序码 | 反序序号 |
| ---- | -------- | ------ | -------- |
| 0    | 000      | 000    | 0        |
| 1    | 001      | 100    | 4        |
| 2    | 010      | 010    | 2        |
| 3    | 011      | 110    | 6        |
| 4    | 100      | 001    | 1        |
| 5    | 101      | 101    | 5        |
| 6    | 110      | 011    | 3        |
| 7    | 111      | 111    | 7        |

通过一些特殊的处理也可以使输出为顺序的，这里不做赘述。

时间序列进行抽取的FFT算法还有许多不同的变体，·1例如舍弃原位运算的特性而支持进行顺序输出，或者更改输入顺序而获得顺序输出等。

3.  按频率抽取（DIF）的FFT算法

仍然限定信号为![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)，且幂为整数时。此时分组选择按前后两半进行分组，此时可以将计算式写为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png)

而根据定义![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png)，那么可以认为![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image026.png)，![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image028.png)。根据k的奇偶性，可以将X(k)分为两部分。经过计算可以得到，此处变换结果是按照奇偶分类的。因此按频率抽取能够将N点的DFT变换分解为两个![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image030.png)的DFT。而这个过程实际上还可以继续分解下去，直到分解为两个点的DFT。

简单比较可以得到DIT和DIF存在的不同。

1.  DIF的输入是自然顺序，但输出却是反序序列，与DIT相反。当然变换顺序经过一些操作后是可以变化的。

2.  DIF和DIT的蝶形运算图实际上是不同的（参考课本图片4-1和4-15）。DIT是在DFT运算后进行的蝶形运算，而DIF是在进行蝶形运算分组处理等之后才进行了DFT运算。

但是实际上两类算法还有许多共同点

1.   复乘法和加法运算次数相同，均为![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png)次运算，计算量上二者是相同的。

2.  两种算法均可以进行原位运算，且对于每一种按时间抽取的FFT算法都有一种按频率抽取的FFT算法流形图与其互为转置。



4.  离散傅里叶逆变换的快速算法（IFFT）

根据DFT公式

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

容易发现在计算过程中替换某一部分内容，两个公式可以相互转化。例如根据以上公式，用![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image034.png)代替![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image036.png)，并将结果的系数![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image038.png)转移，我们就能获得相反的计算。因此原计算流图不变，只将输入输出改变，并更改运算中参与的部分算子，就能实现IFFT算法。此时只需要稍加修改FFT的程序就能完成计算。

5.  N为复合数的FFT算法——统一的FFT算法介绍

上面只对![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)的信号进行讨论，而实际应用中信号长度往往并非这个长度。常用的处理手段是

1.    将原信号补零到最近的一个![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)位置。当差距较小的时候可以使用，但当差距较大时，我们这样的操作会浪费算力。虽然计算结果并不受影响，但是却浪费了时间与计算资源。

2.  使用CZT方法

3.  分解后使用统一的FFT方法。

假定待计算的N点DFT是一个复合数，N=ML，那么可以用下面的公式表达

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image040.png)

其中![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image042.png)不超过L-1，![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image044.png)不超过M-1。下面举例N=12，M=3，L=4，则可以将原信号排列为矩阵的形式

|      | 0    | 1    | 2    | 3    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 1    | 2    | 3    |
| 1    | 4    | 5    | 6    | 7    |
| 2    | 8    | 9    | 10   | 11   |

这样每一个点都可以由![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image046.png)表示，对于输出频谱也是同理。此时输出可以表示为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image048.png)

将![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image050.png)与W项进行逐项组合并求和后，我们得到

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image052.png)

这样能够达成对N点傅里叶变换的分解目的，将N点原信号分解为若干小信号，并通过n（或者k）将输入输出序列的顺序进行对应。其详细运算过程如下

首先将N点信号进行分解，分解方式如上文描述

其次对列做M个L点DFT

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image054.png)

把N个![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image056.png)乘相对的旋转因子![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image058.png)组成新序列![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image060.png)

对行做L个M点的DFT

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image062.png)

对计算结果进行译序。做上述操作仍然遵循FFT的基本思想，即将大点数的DFT转换为较小点数的DFT运算，因此这样的分解操作是可以节省计算量的。

当然，如果N是一个高度可分解的数，当分解为N=ML后，仍然可以将M和L进行进一步分解。流图形式可以仿照前面的画法进行分解，这样可以节约更多效率。

有时分解并不唯一，经常将复合数表示为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image064.png)

当r=2时我们称之为基-2算法，其他时候同理。由于计算机运算时n取2的整数幂时较为方便，因此2的整数幂基数FFT算法受到重视。

 

6.  分裂基FFT算法

理论上讲采用更高的基数可以得到更快的算法，但是此时硬件实现或程序实现都变得更加麻烦。此处应用分裂基算法将会进一步减少运算量并加快运算速度。

设N=Pq，并且![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image066.png)，q=4，则此时可以套用上面的分解方式将x和X表示出来。则

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image068.png)

其傅里叶变换结果也是相似的形式。稍加变换可以得到频域上每四个点抽取的表达式![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image070.png)。将第一个和第三个偶数项进行合并得到一个统一的偶数项![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image072.png)，因此可以将变换结果视为将一个N点DFT变换分解为一个![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image030.png)点的DFT和两个![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image074.png)点的DFT。后面还可以进行进一步分解，如此可以降低运算量。

理论上分裂基FFT的运算量要比一般的基-2FFT少，但是由于出现了较多的条件判断语句与跳转，实际上程序实现的效率提升可能并不明显。当使用专用设计的芯片时，该类算法可能有较大的应用空间。

7.  实序列的FFT

常见的信号大多都是实信号，但是前面的理论计算时，输入序列均为复序列，因此在实际应用中需要进行修改。

1.  一个N点FFT同时计算两个N点序列。假设两个相互独立的N点实序列，他们的傅里叶变换分别为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image076.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image078.png)

 

这两个傅里叶变换可以通过一次FFT获得。我们假设一个序列是实数，一个是虚数，那么整个序列可以看做是

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image080.png)

 

这个序列经过FFT以后可以获得

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image082.png)

根据复序列的特性，我们可以通过这个结果求得两个序列分别的傅里叶变换，即通过一次FFT运算同时计算了两个相同长度实序列的FFT。

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image084.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image086.png)

2.  一个N点FFT运算一个2N点的实序列。

实际上原理大同小异，只是将2N长度实序列进行分组，按奇数和偶数进行分组如下

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image088.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image090.png)

然后将两个分组组成一个复序列，运算后，通过以下关系获取原序列的FFT变换序列。

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image082.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image092.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image094.png)

8.  线性调频z变换算法

前面提到，当N为高度复合的数时，往往要采取CZT算法进行运算。对于一个信号序列，它的z变换为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image096.png)

为了适应z可以沿z平面内更一般的路径取值，可以令z的取样点为![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image098.png),

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image100.png)

M是需要分析的信号的点数，不用等于N，可以比N小。A和W是任意复数，

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image102.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image104.png)

此时在复平面上的取样点轨迹是一条曲率半径变化的圆弧，这里不再赘述各个参数的具体意义。但是经过一定的巧妙代换与推导后，我们发现利用z变换的FFT结果是一个卷积的形式，即

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image106.png)

其中

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image108.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image110.png)

这里的离散卷积可以通过圆周卷积求得，而圆周卷积可以通过FFT计算。由于其频率随n线性增长，因此此信号在雷达系统中又被称为线性调频信号。

当计算量较大时，CZT方法比传统方法要快很多。相比之下CZT还有如下特点

1.  输入序列长度N，但是可以选择只分析M个点。

2.  N和M实际上均可以为素数，不需要高度合成。

3.  频率分辨率是任意的。

4.  螺旋形周线在语音信号分析中有一定优势

5.  起点可以任意选取，可以从任意频率开始输入数据进行窄带的高分辨率的分析

6.  CZT中包含传统DFT的特殊情况，即使是在素数的条件下都能计算。

9.  FFT的应用

常见用途为

1.  利用FFT快速求卷积。时域上的卷积运算实际上相当于频域上的乘法运算，计算有一定优势。常见的计算场景有用FFT求**有限长序列间的卷积及求有限长序列与一很长序列的卷积**等。虽然计算流程在频域转换了一次，并且转换回时域，但由于FFT的高效性，实际上这样的卷积更快。

2.  利用FFT求快速相关。相关计算和卷积计算的公式很像，其计算意义为求解两个序列之间的相关性。

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image112.png)

快速相关计算的速度相当于快速卷积的处理速度。

 

**三、****实验备注**

附带的程序中，包括一个做过底层优化的FFT算法，采用快速数论变换的方法，其运算速度在点数较多的条件下比本章中介绍的算法明显快一些。

**四、****实验验证**

1.  针对典型序列，选择基-2FFT并用C语言编程实现。

首先选取64点FFT。比较其结果。首先是利用C语言的实现。选取信号为

x[i].real = cos(2 * PI / size_x *i) + cos(3 * PI / size_x * i) + cos(4 * PI / size_x *i) + cos(5 * PI / size_x * i);

x[i].img = sin(2 * PI / size_x *i) + sin(3 * PI / size_x * i) + sin(4 * PI / size_x *i) + sin(5 * PI / size_x * i);

即输入信号为一个复信号，实部是四个不同频率的cos的和，虚部是相同频率的sin信号和。观察散点图为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image113.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image114.png)

如图分别为该信号的实部（上）与虚部（下）信号。使用C语言程序对其进行基-2 FFT得到如下结果。

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image115.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image116.png)

其中运算时间为run time:15.555590us。

相同信号使用过MATLAB的内建FFT函数处理得到以下图像

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image118.jpg)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image120.jpg)

MATLAB的计算结果与C程序的计算结果完全相同，计算时间

Elapsed time is 0.000128 seconds.

输入另一信号进行处理，信号为

if(i<10){

x[i].real = cos(2 * PI / size_x *i) + cos(3 * PI / size_x * i) + cos(4 * PI / size_x *i) + cos(5 * PI / size_x * i)+1;

x[i].img = 0;

}

else

{

x[i].real = cos(2 * PI / size_x *i) + cos(3 * PI / size_x * i) + cos(4 * PI / size_x *i) + cos(5 * PI / size_x * i);

x[i].img = 0;

}

给原信号小于10的部分加入一个方波，大于10部分不作处理，计算并绘图得到

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image122.png)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image124.png)

（以上分别为实部与虚部）

使用MATLAB的计算为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image126.jpg)

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image128.jpg)

使用MATLAB计算的结果如图，经过对比计算结果可知，二者的计算结果完全相同。64点FFT运算速度C++略快于MATLAB。

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image130.jpg)

**幅频关系**

2.  用MATLAB自带的FFT函数对结果进行比较。

比较关系如上图所示，在计算的准确度上两者没有明显区别。主要不同出在运算速度上。此处选取8192点进行FFT，统计时间差异。

MATLAB 8192点FFT运算时间

| 序号 | 计算时间（us） | 平均时间（us） |
| ---- | -------------- | -------------- |
| 1    | 178            | 174.0          |
| 2    | 172            |                |
| 3    | 187            |                |
| 4    | 139            |                |
| 5    | 194            |                |

C++ 8192点FFT运算时间

| 序号 | 计算时间（us） | 平均时间（us） |
| ---- | -------------- | -------------- |
| 1    | 3745.341656    | 4175.0315      |
| 2    | 4334.231854    |                |
| 3    | 4606.232458    |                |
| 4    | 4624.454721    |                |
| 5    | 3564.896811    |                |

普通 基-2 FFT C++的计算速度明显会比MATLAB运算更慢。这种速度优势明显体现在变换点数更大时。通过绘制时间-点数图像可以看出，MATLAB的计算速度

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image131.png)

当点数较小时，运算时间较为稳定，当点数增加时，计算速度趋于稳定。

而C++的计算速度为

![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image132.png)

当N足够大时，时间趋近于![img](file:///C:/Users/Prophet/AppData/Local/Temp/msohtmlclip1/01/clip_image134.png)。



 


{% if page.comments %}
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '3', // 可选。默认为 location.href
  owner: 'psycholsc',
  repo: 'temp',
  oauth: {
    client_id: '9183e7259ea6d850a7df',
    client_secret: 'd0a82473ca685629b50ded0553f402b6ba2b2dee',
  },
})
gitment.render('container')
</script>
{% endif %}