---
layout: post
title:  "汇编实验1"
excerpt: "汇编实验翻译"
date:   2018-09-21 21:54:54 +0000
categories: Notes
comments: true
---

实验前需要对基础有所了解。在汇编程序初始化时，会给所有寄存器赋值，赋值如下

1. DS和ES指向相同位置，为PSP的首地址。PSP是程序段前缀（**P**rogram **S**egment **P**refix），是一段附加在程序段前面的内容，一定是CD 20开头。PSP长度为256字节。
2. 后面是数据段。
3. 数据段后面会有一个堆栈段，此时SS是指向这里的首地址的。
4. 堆栈段后是代码段，此时CS:IP指向首地址。

我们简单看一下PSP段

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/PSP.png)



## 老师给的代码

这个程序是老师上课时给出的程序，但是并没有在实验上使用。

以下是程序运行后的内存，从CS=200H开始进行观测。

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM1.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM4.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM5.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM6.png)

由于网页排版问题，文字很不清晰，无法进行参考，这里是图片版。

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM2.png)

[图片下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM2.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM3.png)

[图片下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM3.png)

由于系统编码问题，无法使用中文进行描述，所以索性改成了英文描述。

上面有两处补充注释需要说明，上面的空间写不下。

1. 关于ASSUME伪操作，汇编中源程序可以定义多个SEGMENT，但每一个段都要和段寄存器建立一种对应关系，ASSUME就是这个建立关系的语句。段寄存器分别有CS、DS、ES、SS，在代码中我们也建立了这样的关系，我们可以认为CODE区对应CS等。但是注意，即使是这样ASSUME了，后面仍然需要写相关代码，例如后面47到50行。ASSUME语句是给编译器的说明语句，实际上并没有什么用。在本环境下，如果每一个段只有一个的话，不加这句话对程序也没有什么影响。
2. 关于PROC后面的FAR的问题，伪操作PROC可以用一些参数来描述，例如NEAR和FAR。FAR的目的是将程序定义到一个远区，这样可以做段间的远调用。如果子程序和调用程序在一个段内,子程序参数设置为NEAR；如果子程序和调用程序不在一个段内,子程序参数设置为FAR。系统把主程序当作DOS调用的一个子程序，DOS内核与主程序不是在同一个段地址内，所以主程序参数要用FAR。

问题修正：

1. Line 18 在DW型数据条件下，保存时是逆序的，即先保存 01 后保存 00，其他同理。



[程序代码下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/tempsrc/my.asm)



## 真实上机实验

### 预备实验

2018.10.10晚，开始了第一次正式的汇编实验。这个实验才让我发现一些问题，因为很多运行结果和我们Google到的并不一样。首先贴上程序

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2.PNG)



*写这个代码的老师也还行，MAIN写成了MIAN，后面居然全都将错就错地写成了MIAN，绝了*

我们可以看到，程序的01-04行是DATA SEGMENT，数据段。数据段内容全部为BYTE型，显示在内存中应当是00-0F共16个BYTE，后面是20个00占位符。

程序的05-07行定义了一个栈，初始值为100个00（BYTE型）。

08行后都是代码段，CODE SEGMENT。后面就该说狗屎的内容了。我们编译这个程序之后进行调试，首先观察一下寄存器

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2I.png)

此时运行到第一步，DS入栈。这个操作是一个固定操作，如果我们在程序中使用了PROC这样的伪指令，就要用这个固定搭配，但是这个搭配也比较老旧了，实际上现在也不这样使用了。整个固定搭配就是DS入栈，AX赋0，AX入栈，为后面的RET做准备。

然后就开始了第16行的代码。但是此时问题还没有说完。我们明明看到了寄存器的状态，但是通过寄存器存储的地址并不能找到我们需要的数据。例如我们看到我们的SS寄存器是076F，但是我们查看此处的内存，并没有看到相关的东西

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2II.PNG)

也就是说，前面的ASSUME语句虽然建立了一种关联，但是却并没有对他们进行赋值，寄存器的初始值是缺省的默认值。

我们继续单步执行，可以看出，DATA段对应的地址段应当是0770

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2III.PNG)

截止到这一步，DS终于指向了DATA段，和前面的ASSUME没有任何关系。顺便，ES也指向了DS相同的位置0770。其实我也不知道为什么ES默认指向00BF。

21-23行的含义就是给CX赋值10H，SI赋值为BUF1的**偏移量**（OFFSET），DI赋值为BUF2的偏移量。分别是0000和0010（很容易理解，0000H段开始保存了16个BYTE，下一个就是0010H段）。

24行给了一个标记L，为后面的跳转标注。

25行是一个寄存器间接寻址，将SI中保存地址对应的内存（即BUF1的第一个值）赋值给AL，赋值后AL=00，AX=0700如图

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2IV.PNG)

26行将AL赋值给DI所指向的位置，即BUF2的开头。

27、28行INC对SI和DI分别加1，指向下一个BYTE

29行对CX减1，这个是一个循环标识符，初值10H表示循环10H=16D次，每循环一次自减1。

30行JNE，当ZF（Zero Flag）==0时，即上一步运算不为0时，跳转至L。这样我们就循环16次，最后CX=0不再跳转，程序执行RET返回。

后面表示程序结束，ENDP与PROC对应，ENDS与SEGMENT对应，最后的END表示子程序结束。

### 实验1 - 1 Hello World

不管是写什么程序，都要从Hello World开始= =

编写思路就是在内存中存储字符串“Hello World”，然后通过指令输出。输出指令通过INT 21H中断指令执行。程序如下

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/HW.png)

[程序下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/tempsrc/Hello World.asm)

程序原理很简单，首先在数据段定义一个变量String，是字型（BYTE）内容就是“Hello World”。注意在最后有一个美元符号“$”，这个符号代表字符串**输出**在此处终结。如果不加这个符号就会一直输出。

程序到14行前都是套路，标准格式，14-16行用来输出。中断21H指令有很多，只要将对应的指令代码保存在AH中，再使用INT 21H中断指令，程序就会在屏幕上显示字符串。需要注意此时的串地址应为DS:DX，这里采用LEA，取有效地址，将其赋值到DX中，程序就会从此处一直输出到“$”。

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/hwre.png)

以上是输出结果。

### 实验1 - 2 统计











