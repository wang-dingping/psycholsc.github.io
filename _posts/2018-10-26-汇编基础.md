---
layout: post
title:  "汇编基础"
excerpt: "汇编实验翻译"
date:   2018-10-26 21:54:54 +0000
categories: Notes
comments: true
---



先简单理解一下汇编程序的结构。首先编译器会根据代码的定义，留出data段和stack段，后面才是code段。data段和stack段都是可以预先填充的，实际上data段就是在编程的时候定义的部分，stack可以填充也可以预留。代码段就不同了，它会被编译成机器码，每条指令最长为6位十六进制码，储存在内存中。在他们最前面还有一段256字节的程序段前缀PSP，这里先不讲。每一条指令都有唯一对应的机器码。

## 1. 8086汇编指令系统

- 汇编指令的书写形式

  操作指令 目标操作数,源操作数;注释

  这里只有操作码是每一步都必须加上的，其他的都是可选项。注意指令间隔是逗号，虽然看起来很像shell。

  每一句汇编指令结束后都以回车换行。

- 汇编的指令执行时间一般以时钟周期数来计算。加法、传递之灵跳转指令和移位运算都是速度较快的指令，而相比之下乘除法的运算就要慢得多（时序长几十倍左右）。

- 寻址方式不同所需的时钟周期数也不同，寄存器间接寻址<直接寻址<基址变址<相对基址变址。

- 通用数据传输指令

- mov dst,src;将源操作数传递给目标操作数。指令执行后目标操作数值被改变而源不改变。一般来说目标操作数不能使立即数，也不能将一个存储器直接传递到另一个存储器中。传递时就经常会用到寄存器。

  - - 寄存器：AX常用于计算，CX常用于循环计次，DX也用于计算，在没有乘除法的时候也会用于作为临时寄存器使用。
    - SI是源变址寄存器，寻址的时候会用到，常和SS搭配；

  - 两个操作数长度一般要相同，不能AX与BL相互赋值，如果硬要操作不明确的信息，需要显式指明 （word ptr

  - 指令指针IP不能作为操作数

  - CS不能被mov修改

  - 段寄存器之间不能直接mov，需要经过DX等通用寄存器

  - 立即数不能直接送入段寄存器（但是可以直接送入通用寄存器和存储器）

  - 两个操作数不能同时为存储器寻址方式

  - **mov操作是不会影响到标志位的**

  - 应用举例：

    mov AL, buf; 将buf这个地址内的内容送入AL中。定义变量的时候buf标记的是首地址。

    mov AX,[SI];将DS+SI指向的内容送入AX。实际上DS还需要左移一个十六进制位。

    mov [DI],DX;将DX中的内容址送入DI指向的地址中。DI默认是与DS对应的，即修改DS:DI中内容为DX

    mov SI,ES:[BP];将ES:BP这个地址中的内容转移到SI中

    mov AX,buf[BX+SI];相当于mov AX,[BX+SI+buf]，一般情况下需要buf是一个word型。（这他妈好像还有个什么牛逼的名字叫相对基址加变址寻址方式？？）

- 出入栈指令。堆栈是一种先进后出的结构，**其中无论何时SP都是指向栈顶的**。入栈就是**push**指令，出栈就是**pop**指令。堆栈操作必须以字为单位。出入栈不是运算，也不会影响标志位。与mov不同的是，不能将一个立即数作为操作数入栈，也不能对CS做出栈pop操作。
  - push是入栈。入栈操作是先将SP自减2，栈顶指针向上移动2位，从而可以容纳一个字；压栈的时候，先读入高两位压入，再读入低两位压入。低两位存在内存的低两位上，高两位存在内存的高两位上。（学校这个MASM环境里面，需要手动指定SP的位置，否则会出现乱七八糟的问题）
  - pop是出栈。首先将栈中的内容读出到指定寄存器，然后将SP自加2，释放空间。
- 交换指令。XCHG是一个简单的交换指令，作用就是将两个内容交换，此过程不影响到寄存器。段寄存器的内容不允许交换，立即数不能交换。（这几把指令我就没用过）

  - xchg BX,[BP+SI];将BX的内容和SS:[BP+SI]交换。





## 2. 实验

## 预备内容

实验前需要对基础有所了解。在汇编程序初始化时，会给所有寄存器赋值，赋值如下

1. DS和ES指向相同位置，为PSP的首地址。PSP是程序段前缀（**P**rogram **S**egment **P**refix），是一段附加在程序段前面的内容，一定是CD 20开头。PSP长度为256字节。CD20机器指令实际对应INT 20H。
2. 后面是数据段。
3. 数据段后面会有一个堆栈段，此时SS是指向这里的首地址的。
4. 堆栈段后是代码段，此时CS:IP指向首地址。

我们简单看一下PSP段

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/PSP.png)











## 老师给的代码

这个程序是老师上课时给出的程序，但是并没有在实验上使用。

以下是程序运行后的内存，从CS=200H开始进行观测。

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM1.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM4.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM5.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM6.png)

由于网页排版问题，文字很不清晰，无法进行参考，这里是图片版。

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM2.png)

[图片下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM2.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM3.png)

[图片下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/ASM3.png)

由于系统编码问题，无法使用中文进行描述，所以索性改成了英文描述。

上面有两处补充注释需要说明，上面的空间写不下。

1. 关于ASSUME伪操作，汇编中源程序可以定义多个SEGMENT，但每一个段都要和段寄存器建立一种对应关系，ASSUME就是这个建立关系的语句。段寄存器分别有CS、DS、ES、SS，在代码中我们也建立了这样的关系，我们可以认为CODE区对应CS等。但是注意，即使是这样ASSUME了，后面仍然需要写相关代码，例如后面47到50行。ASSUME语句是给编译器的说明语句，实际上并没有什么用。在本环境下，如果每一个段只有一个的话，不加这句话对程序也没有什么影响。
2. 关于PROC后面的FAR的问题，伪操作PROC可以用一些参数来描述，例如NEAR和FAR。FAR的目的是将程序定义到一个远区，这样可以做段间的远调用。如果子程序和调用程序在一个段内,子程序参数设置为NEAR；如果子程序和调用程序不在一个段内,子程序参数设置为FAR。系统把主程序当作DOS调用的一个子程序，DOS内核与主程序不是在同一个段地址内，所以主程序参数要用FAR。

问题修正：

1. Line 18 在DW型数据条件下，保存时是逆序的，即先保存 01 后保存 00，其他同理。



[程序代码下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/tempsrc/my.asm)











## 真实上机实验

### 预备实验

2018.10.10晚，开始了第一次正式的汇编实验。这个实验才让我发现一些问题，因为很多运行结果和我们Google到的并不一样。首先贴上程序

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2.PNG)



*写这个代码的老师也还行，MAIN写成了MIAN，后面居然全都将错就错地写成了MIAN，绝了*

我们可以看到，程序的01-04行是DATA SEGMENT，数据段。数据段内容全部为BYTE型，显示在内存中应当是00-0F共16个BYTE，后面是20个00占位符。

程序的05-07行定义了一个栈，初始值为100个00（BYTE型）。

08行后都是代码段，CODE SEGMENT。后面就该说狗屎的内容了。我们编译这个程序之后进行调试，首先观察一下寄存器

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2I.png)

此时运行到第一步，DS入栈。这个操作是一个固定操作，如果我们在程序中使用了PROC这样的伪指令，就要用这个固定搭配，但是这个搭配也比较老旧了，实际上现在也不这样使用了。整个固定搭配就是DS入栈，AX赋0，AX入栈，为后面的RET做准备。

然后就开始了第16行的代码。但是此时问题还没有说完。我们明明看到了寄存器的状态，但是通过寄存器存储的地址并不能找到我们需要的数据。例如我们看到我们的SS寄存器是076F，但是我们查看此处的内存，并没有看到相关的东西

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2II.PNG)

也就是说，前面的ASSUME语句虽然建立了一种关联，但是却并没有对他们进行赋值，寄存器的初始值是缺省的默认值。

我们继续单步执行，可以看出，DATA段对应的地址段应当是0770

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2III.PNG)

截止到这一步，DS终于指向了DATA段，和前面的ASSUME没有任何关系。顺便，ES也指向了DS相同的位置0770。其实我也不知道为什么ES默认指向00BF。

21-23行的含义就是给CX赋值10H，SI赋值为BUF1的**偏移量**（OFFSET），DI赋值为BUF2的偏移量。分别是0000和0010（很容易理解，0000H段开始保存了16个BYTE，下一个就是0010H段）。

24行给了一个标记L，为后面的跳转标注。

25行是一个寄存器间接寻址，将SI中保存地址对应的内存（即BUF1的第一个值）赋值给AL，赋值后AL=00，AX=0700如图

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp2IV.PNG)

26行将AL赋值给DI所指向的位置，即BUF2的开头。

27、28行INC对SI和DI分别加1，指向下一个BYTE

29行对CX减1，这个是一个循环标识符，初值10H表示循环10H=16D次，每循环一次自减1。

30行JNE，当ZF（Zero Flag）==0时，即上一步运算不为0时，跳转至L。这样我们就循环16次，最后CX=0不再跳转，程序执行RET返回。

后面表示程序结束，ENDP与PROC对应，ENDS与SEGMENT对应，最后的END表示子程序结束。

### 实验1 - 1 Hello World

不管是写什么程序，都要从Hello World开始= =

编写思路就是在内存中存储字符串“Hello World”，然后通过指令输出。输出指令通过INT 21H中断指令执行。程序如下

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/HW.png)

[程序下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/tempsrc/Hello World.asm)

程序原理很简单，首先在数据段定义一个变量String，是字型（BYTE）内容就是“Hello World”。注意在最后有一个美元符号“$”，这个符号代表字符串**输出**在此处终结。如果不加这个符号就会一直输出。

程序到14行前都是套路，标准格式，14-16行用来输出。中断21H指令有很多，只要将对应的指令代码保存在AH中，再使用INT 21H中断指令，程序就会在屏幕上显示字符串。需要注意此时的串地址应为DS:DX，这里采用LEA，取有效地址，将其赋值到DX中，程序就会从此处一直输出到“$”。

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/hwre.png)

以上是输出结果。



### 实验1 - 2 统计

输入一组数据，分类统计数据中正数、负数和零的个数，并分别存入内存字变量Positive、Negative、Zero中，数组元素个数保存在其第一个字中，使用Debug查看Positive、Negative、Zero三个变量的数据。

**在最前面加粗引起注意，此处讲解的代码是张笈老师上课讲解的相似代码，实验代码将在最后提供下载地址！**

**在最前面加粗引起注意，此处讲解的代码是张笈老师上课讲解的相似代码，实验代码将在最后提供下载地址！**

**在最前面加粗引起注意，此处讲解的代码是张笈老师上课讲解的相似代码，实验代码将在最后提供下载地址！**

代码数据段

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp1-2I.png)

首先定义字类型字符串message和message2，然后定义了字类型maxlen。首先是输入最长字符数，这里赋值为6；然后是一个预留位置0，后面将用作计次变量；然后定义了6个09H，这里实际上用来临时保存输入的数据。

定义了三个字符串，并且在每一行后使用0DH 0AH代表回车换行。，输出以‘$’为结束。

定义了三个统计变量，分别为count0-2。

以下是代码段

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp1-2II.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp1-2III.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp1-2IV.png)

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp1-2V.png)

代码段很长，有些程序并不重要。代码段从21行开始，首先给几个寄存器设置对应关系，其实没什么卵用的一句话，加不加程序一样跑；

START标记程序的入口，即从这里执行。

24-25行定义DS指向DATAS的首地址，27-30行定义的是输出。CX=10在这里代表一共允许十个输入。注意后面会用到LOOP操作，LOOP操作的循环次数由CX指定，CX=10即循环10次，10次后就不再进行LOOP操作。DX获得message的首地址，给AH赋值09H后调用21H中断，触发输出，输出DX指向的地址中的内存值（直至$）。

31行next标记了一个入口，一会会回来；

32行进行了段间调用 read_exch子程序，跳转至70行。

71行首先push了CX，将CX压栈，实际意义是将CX保存，因为CX是标记总循环次数的变量。；

72-74行定义了一个输入操作，输入操作的规则是，DS:DX指定输入的最长字长，[DS:DX+1]中返回输入的实际长度。

78-80定义了一个输出，输出了一个回车换行。

对AX清零，CL指向实际输入长度，并以此进行计数。由于输入是一个字符一个字符输入的，因此要对每一个字符进行分别输入。BX指向maxlen后面两个字的位置（保存当前输入的空间），这里就是数据段里maxlen中初始化6个9的位置。





循环开始，对DH 清零，将DL中赋值为BX所指的值。假如我前面输入123，这里BX指向的内存区域的值就是1，后面就是2和3。假设DL此时就是1，将DL和0FH进行与（AND）操作（即89行），可以将十六进制值转化为十进制值（仅数字）。此时DL的值就由31H转化为了01H。

令CH=10（即0AH），然后调用MUL CH，此时都是8位二进制的乘法，规则为AX中保存AL*CH（无符号数乘法）。第一次循环AX是0000，因此AX仍然是0000。调用加法将AX加DX，AX变成了0001。

BX自加（后移一个，指向输入的2），CL自减（CL中保存的是实际输入的位数），表示已经完成了一位输入的处理，按照此处的假设还剩3-1=2位需要处理。JNZ判断CL是否为0，不是0就跳转again进行循环。

然后又对DH清零，DL赋值为BX指向的2，与操作后得到02H。CH赋值0AH，做乘法后AX=0AH，调用加法后AX=000C。BX自加，CL自减，还剩一位，JNZ跳转回到again位置。

然后又对DH清零，DL赋值为BX指向的3，与操作后得到03H。CH赋值0AH，做乘法后AX=0078，加法后AX=007B H=123 D。我们发现实际上每次都是对AX进行了一个乘10+DX的操作，在本假设中，输入123，AX的变化为

1->10+2=12->12*10+3=123

如此操作可以在AX中获得16进制的输入数字。

BX自增指向无意义区，CL自减为0，经过JNZ后不进行跳转，将AX的值转入DX中后弹出CX，程序返回。程序开始时CX入栈，保存的值是000A，即10，此处出栈，CX为000A。

回到前面执行到的32行，继续向下执行。DX保存的数字是输入数字的16进制码，直接与10比较，小于10则count0自增；否则与100比较，小于100则count1自增；否则不进行比较，直接对count2自增。

至此一个输入与统计循环就完成了，程序进行回到next进行循环，再一次调用read_exch进行下一个数字的读取。

注意此时是用的LOOP，本质上是对CX进行自减一次，然后判断是否为0，如果CX为0就会跳出循环。

执行到输入完成是第52行，此时屏幕上打印出一行“output”，置BX为display的首地址，AL指向count0（第一个统计变量的值），调用段间exch_to_asc10子程序。跳转到102行。

首先将AH置零，令DL=10。DIV运算是用AX/DL，将余数保存在AH，商保存在AL。AX此时记录的是第一个统计量的值，除以10后OR 3030H的作用是转化为ASCII码中对应值，做此操作后AH和AL进行交换，AL中保存的就是这个数字的ASCII码。以上分析是针对一位十进制数分析的，对于两位亦然，因为AH中就是十位，AL中就是个位。这也是display在显示的位置留两个预留位置的原因。

因此我们说a_number_end这一段的目的就是将内存中保存的十六进制数字转化为ASCII码。程序在保存时为了方便而采用十六进制保存十进制数，但是输出的时候只认定ASCII码对应的字符，因此要转换到ASCII码。

处理完成后将BX内容移交到DX中，使用中断21H输出。

在本程序中，后面的代码没有什么作用了。

[本程序代码下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/tempsrc/class.asm)

实验里面给的题目真让人头大。输入数字是有符号数，这样就很狗屎了。

我操写了好久好久好久好久

最后照着老师程序改了改

考试要是roll到这种题直接去世啊

效果图

![](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/asmexp1-2VI.png)

[代码下载地址](https://raw.githubusercontent.com/psycholsc/psycholsc.github.io/master/assets/tempsrc/exp1-2.asm)









