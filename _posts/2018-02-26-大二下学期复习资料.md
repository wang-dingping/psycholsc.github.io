---
layout: post
title:  "Ex - 0 大二下学期复习资料"
date:   2018-02-23 21:01:13 +0000
categories: git push
comments: true
---
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

# 数字电路与系统设计
---

## 一、数制与编码

### 1.1 数制

任意进制的数都是由若干位数字组成，每位代表不同的权位。对于$$R$$进制数$$N$$可以表示为

$$\left ( N \right )_{R}=\sum_{i=-m}^{n-1}K_{i}R^{i}$$

因为整数部分存在权重为$$R^{0}$$的项

对于任意$$R$$进制数，数中出现的一位最大数为$$R-1$$，即十进制中出现最大单个数为9,16进制为F（ABCDEF分别代表9后的单个数字）

设计8或16进制的目的是便于计算和记忆。任意进制向10进制转换时，计算方式为按位加权，如

$$\left ( 101.001 \right )_{2}=1\cdot 2^{2}+0\cdot 2^{1}+1\cdot 2^{0}+0\cdot 2^{-1}+0\cdot 2^{-2}+1\cdot 2^{-3}=\left ( 5.125 \right )_{10}$$

对于更高进制仍然适用。

### 1.2 数制转换

对于二进制、八进制和十六进制之间的转换比较容易。

二进制数向八进制转换为例，**从小数点开始**分别向左、右每**三位**分一组，**不足补零**，类似于

$$\left ( 10010111.1101 \right )_{2}=(\underline{010}\, \underline{010}\, \underline{111}.\underline{110}\, \underline{100})_{2}=\left ( 227.64 \right )_{8}$$

然后按照对应关系，将每组二进制数转为8进制即可。相反的八进制到二进制也是相同的道理，将每个数转化为二进制并赋予其三个位，连接后去掉两端的0即可。

十六进制同理，只不过由于$$2^{3}=8$$，$$2^{4}=16$$，在操作时要每**四个**一组。

十进制数向二、八、十六进制转换时，**整数部分**使用短除法，除数是$$R$$进制的$$R$$。将每位余数（0也算）按顺序记下直到最后一个不为0的项，然后**反向**写出就是二（或八、十六）进制数；小数部分使用乘法，乘数是小数和$$R$$。小数与$$R$$相乘的整数部分保留，小数部分继续参与乘法直到为0，将每一步得到的整数顺序连起来就是小数部分。这里经常得不到0，所以只能取近似值。注意转换的误差，误差（精度）被描述为

$$\frac{\left (Target  \right )_{R}-\left ( Result \right )_{2}}{\left (Target  \right )_{R}}\times 100\%$$

通常取正。

十进制进行转换时可以先转换为二进制数，然后二进制数再向八或十六进制转换，口算速度会快一些。

### 1.3 二进制符号数的表示方法
**原码表示法**使用一位二进制数表示符号，其中0为正、1为负。其余部分使用绝对值的二进制表示。简单的说就是最高位表示符号，其他位表示数字。原码可以表示的范围是$$-\left ( 2^{n-1}-1 \right )\sim \left ( 2^{n-1}-1 \right )$$

**反码表示法**使用一位二进制数表示符号，其中0为正、1为负。正数仍使用原码，负数则使用反码表示。反码的计算就是对应位取反，符号位不算。反码表示的范围是$$-\left ( 2^{n-1}-1 \right )\sim \left ( 2^{n-1}-1 \right )$$

**补码表示法**使用一位二进制数表示符号，其中0为正、1为负。正数仍使用原码，负数则使用补码表示。补码的计算是$$\left ( N \right )_{补.n}=2^{n}-N$$。补码表示的范围是$$-2^{n-1}\sim \left ( 2^{n-1}-1 \right )$$
计算补码最常用的方法就是在原二进制数前**用0补全n位**后取反**加一**

计算机中利用补码来进行加减运算，有利于硬件资源的简化设计和充分利用。以计算A和B两个二进制正数为例，首先写出A、B、-A、-B四个数的补码，然后根据加减要求对四个数进行求和运算。假设补码分别为$$N_{1}$$、$$N_{2}$$、$$2^{n}-N_{1}$$和$$2^{n}-N_{2}$$。

1. 对于加法结果就是$$N_{1}+N_{2}$$。
2. 对于A-B，结果就是$$N_{1}+2^{n}-N_{2}$$，即$$2^{n}-(N_{2}-N_{1})$$。结果取决于$$N_{2}-N_{1}$$的符号，这里需要根据A和B来判断。实际计算时只需要看一下补码运算结果，如果补码运算结果的符号位是0，那么一定是正数，补码按原码处理；如果补码的符号位是1，即计算结果为负数，那么对补码再次求补码得到原码。
3. 对于B-A结果与上面相似
4. 对于-A-B，结果一定为负数，按负数处理，再次求补码得到原码。

这里容易出现的错误是溢出。由于运算器只有指定位数，计算结果超出的位数要忽略。如果在精度范围内，溢出后计算的结果仍然正确；如果计算结果在精度范围外。通过A+B或-A-B计算的结果就是可能错误的。简单的判断方法是
>符号位和最高数字位不同时发生进位（-A-B） 或 不同时无进位（A+B）时有**溢出错误**(OverFlow)发生。

### 1.4 二-十进制编码
$$2^{n}$$了解一下：1,2,4,8,16,32,64,128,256,512,1024……

其中$$2^{10}=1024$$

在数字系统中使用的是二进制数，经常会对10进制数进行编码。常见的编码方式有8421BCD、5421BCD、2421BCD、余三码、余三循环码等。由于$$2^{3}=8<10$$，$$2^{4}=16>10$$，因此选择每四位二进制编码一位十进制数，其中有10个是**有效编码**，6个是**无效编码**。

提到的几类编码中，前三类都是数字+BCD的命名，其意为四位二进制数的权重，BCD即Binary Coded Decimal。这一类编码称为**有权码**，余三码和余三循环码属于**无权码**。将十进制数转化为相应的编码只需要按位处理即可，每一位十进制数都由四位二进制代替，例如
$$\left ( 216 \right )_{10}=\left ( 0010\: 0001\: 0110 \right )_{8421}$$
其余方式同理。
判断是否有权码需要所有数字都进行判断。

有时会计算使用BCD编码后的数字进行加减法，如果某一位数字超出四位编码或仅仅超过10，我建议**用十进制**算完后转回二进制。

8421恰好是普通二进制数的权位分配，其他的编码方式则不是。对于5421BCD，前五位按照权位可以顺利写出，后五位的第一个数是1，其余和前面五个数相同。对于2421编码，前五个数可以通过相同的方式写出，后面五个数分布与前五个对称且自反。余三码就是8421码向后移三位，余三循环码每相邻数之间仅一位有不同，即逻辑相邻。其编码前五个数和后五个数除了第一位自反外是对称的。

### 1.5 格雷码

在组合电路中，为避免译码噪声（毛刺）的出现，常使用格雷（Gray）码。相邻两个数字编码只有一位不同（逻辑相邻）。在其他应用中格雷码的使用也十分常见。余三循环码就是采用了格雷码中的十组编码（中间十组）。至于为什么说这种逻辑相邻的编码存在顺序，则要考察其计算过程。

按照定义，格雷码的计算是如下的方式：
1. 对于一位格雷码，就是0,1
2. 对于两位格雷码，编码结果是00,01,11,10（除第一位自反以外是对称的）
3. 对于三位格雷码，编码结果是000,001,011,010，110,111,101,100（除了第一位自反以外是对称的）
4. 对于四位……

格雷码和二进制数之间可以进行互相转化。引入**异或**计算

$$ F=A \oplus B=\left\{
\begin{aligned}
1\: where\: A \neq B \\
0\: where\: A = B 
\end{aligned}
\right.
$$

举例1011对应的格雷码。第一位保持不变为1，第二位是第二位二进制码与前一位二进制码的异或值，1。同理后面每一位都是该位二进制与前一位二进制的异或值，结果为1110

对于1011格雷码对应的二进制码，第一位仍然保持，第二位是该位二进制与前一位结果的异或值，后面计算方式相同，结果为1101。

### 1.6 ASCII 字符集

ASCII字符集是一个七位二进制码编码的字符集，共128个。33个控制符，95个字符。在这里引入了16进制符方便表示。表格略。

### 1.7 检错码和纠错码

数字信号传输过程中经常出现错误（误码），对于只需要检测出错误码的场合，我们只需要检错码检查；对于需要纠错的场合，我们引入纠错码。
为了检验信息是否出错，一种比较简单的检错码是奇偶校验码。除了被发送的信息外，我们经常在最高位附加一个校验位，使得整个码元中的1的数量为奇数或偶数个。这样的操作通常由逻辑运算异或完成。

这样的操作往往会降低传输效率。因为每一个码元都会多出一个本身不承载信息的校验位，因此传输效率变成了

$$\eta =\frac{n}{n+1}\times 100\%$$

当然在误码率较高的时候这样的操作就不适用了。

简单的纠错码是二维奇偶纠错码。在信息块的行和列都各自附加一个校验码，此时就可以通过两个校验码的提示的错误位置进行纠错。由于只会出现0或者1，因此我们就可以通过直接取反的方式纠错。

第一章完

---
# 自动控制原理
---
妈耶到底谁来跟我讲讲今天老师上课到底说啥了。

开环控制存在很多弊端，因为他不能检测到输出究竟发生了什么变化，只能根据预先设定对输出进行调控，例如微波炉。同样的可以对外界的噪声干扰进行检测（进行干扰补偿），但是仍然不会对输出进行检测。对输出进行检测的是闭环控制系统，现在几乎没有开环的系统了。

对控制系统有三个基本要求，**稳**定性、**准**确性和**快**速性。

---
# 通信电路与系统

## 第一章

### 1.1 概述

其实这一段啥都没说

### 1.2 通信和通信系统

通信就是将信息从发送端传输到接收端，典型现代通信系统如下

->输入变换器->发射设备->信道->接收设备->输出变换器->

其中信道上存在噪声干扰。

非电信号经过输入变换器的转换后成为了某种电信号，称为**基带信号**

基带信号经过某种变换后进入信道，以便信号进行有效传输。变换过程为调制，一般由调制器进行调制，然后经过载波放大后发射。

简单介绍无线电波频段的划分

| 传播方式 | 波段名称 | 波长范围 | 频率范围 | 频段名称 | 主要用途 | 
| :- | :-: | -: | :-: | :-: |
|地表波| 长波 | 3000~30000m| 10-100kHz | 低频LF | 电报 | 
|地表波| 中波 | 200~3000m| 100-1500kHz | 中频MF | 广播 | 
|地表波&电离层| 中短波 | 50~200m| 1500-6000kHz | 中高频IF | 电报、广播 | 
|地表波&电离层| 短波 | 10~50m| 6-30MHz | 高频HF | 电报、广播 | 
|视距波| 超短波、米波 | 1~10m| 30-300MHz | VHF | 通信、电视、导航 | 
|视距波| 超短波、分米波 | 10~100cm| 300-3000MHz | UHF | 电视、雷达、导航 | 
|视距波| 微波、厘米波 | 1~10cm| 3-30GHz | SHF | 中继通信、卫星通信、雷达、导航等 | 
|视距波| 微波、毫米波 | 1~10mm| 30-300GHz | EHF | 中继通信、卫星通信、雷达、导航等 |
|光波| 激光 | <3e-4m| \>1e3GHz |  | 通信 | 

接收机部分功能相反，从信道中解调原有的信号，主要是选频放大器、解调器组成。

*实际上上述全过程中都存在噪声的影响*

### 1.3 模拟和数字通信系统

信息一般分为连续和离散。连续时间上信息状态连续则为连续信号，状态可数且时域不连续则为离散。

**一般**我们说模拟信号是连续的，而数字信号是离散的。模拟信号不限于仅在模拟通信系统中传输。我们常常利用数模转换的技术，将模拟信号转换为数字信号进行传播，接收信号时再利用转换器转换为原有信号。由于数字通信抗干扰能力强、易于加密、便于计算机处理等原因，目前存在数字信号替代模拟信号进行传输的趋势。

在模拟信号传输过程中经常要进行调制，即利用基带信号去改变高频信号某个参量的过程。此时高频信号上已经有了相应的基带信号信息，这个高频信号就是载波。对应的反变换过程叫做解调。高频信号易于发射（波长较小，对天线尺寸要求较小），便于同时传播多路不同的基带信号。


模拟调制分为**正弦波调制**和**脉冲调制**两种。正弦波调制的载波是正弦波，基带信号控制了其振幅、频率、相位等参数的调制被分别称为幅度调制（AM）、频率调制（FM）、相位调制（PM）。脉冲调制的载波是脉冲序列。基带信号通过改变其幅度、宽度、位置等参数的调制被称为脉冲幅度调制（PAM）、脉宽调制（PWM，又称脉冲持续时间调制PDM）、和脉位调制（PPM）。

通信系统中为了在同一信道同时传输多个不同基带信号，常常把不同基带信号调制到不同的载波频率上。。各个广播电台就采用了不同的载波频率。调制类型因信号而异，但是每个载波频率之间间隔一定要足够大，这个间隔是**防护频带**，避免信号之间相互干扰。我国广播电台的载频间隔就不小于9kHz。

今晚lay了，鸽了。2018-02-27。

{% if page.comments %}
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '2', // 可选。默认为 location.href
  owner: 'psycholsc',
  repo: 'temp',
  oauth: {
    client_id: '9183e7259ea6d850a7df',
    client_secret: 'd0a82473ca685629b50ded0553f402b6ba2b2dee',
  },
})
gitment.render('container')
</script>
{% endif %}